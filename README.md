# Дельцов Даниил Витальевич, БПИ226

Вариант 40. Разработать программу вычисления числа π с точностью не хуже 0,1% посредством дзета-функции Римана.

Работа выполнена на оценку 9

[Код на ассемблере с комментарями](https://github.com/danikd1/IndividualHomework_2_ABC-)

Теперь пройдемся по реализации:
Программа main.s содержит 2 подпрограммы реализованные с помощью макросов: calculate_pi() - макрос использует полученное значение дзета-функции для вычисления приближенного значения числа π. Связь между дзета-функцией Римана при s = 2 и числом π установлена формулой Эйлера -> исходя из этого, чтобы найти значение π, нужно извлечь квадратный корень из утроенного значения дзета-функции и умножить его на 6, approximate_zeta() - #Макрос возвращает накопленную сумму, которая является приближенным значением дзета-функции Римана -> работает по следующему принципу: начинает суммирование ряда для ζ(2) и продолжает, пока вклад каждого следующего члена ряда не станет меньше заданной толерантности, output() - выводим получившиеся приближенное значения числа π B. Комментари написаны к каждой функции и сложным фрагментам кода, поясняющие выполняемые действия. Описаны фактические параметры в main.s. Так же во все подпрограммы аргументы передаются через параметры. Т.к задача не предусматривает входные данные, то поддержка многократного использования различных наборов входных данных отсутствует -> решение задачи не нуждается в создании дополнительной тестовой программы из-за отсутствия различных ситуаций.

Реализовано решние задачи на высокоуровневом языке Python:
```markdown
```python
import math

def calculate_pi(zeta_value):
    return math.sqrt(6 * zeta_value)

def approximate_zeta(s, tolerance):
    sum = 0.0
    k = 1
    while True:
        term = 1 / k**s
        sum += term
        if term < tolerance:
            break
        k += 1
    return sum

# Точность, необходимая для π, равная 0.1% от его значения
pi_precision = 0.001 * math.pi

# Толерантность для приближения зета-функции, взято из условия для π
zeta_tolerance = (pi_precision ** 2) / 6

zeta_value = approximate_zeta(2, zeta_tolerance)
pi_approx = calculate_pi(zeta_value)

print(f"Approximated value of pi: {pi_approx}")

Ниже приведены скриншоты работающей программы:
1.<img width="1792" alt="Снимок экрана 2023-11-05 в 23 03 50" src="https://github.com/danikd1/IndividualHomework_2_ABC-/assets/36849026/f4ef9aef-c921-46d4-ac1e-f6ec4895c80b">
2.<img width="1792" alt="Снимок экрана 2023-11-05 в 23 04 08" src="https://github.com/danikd1/IndividualHomework_2_ABC-/assets/36849026/a414ddbc-1afa-4073-af60-5196356156ee">
