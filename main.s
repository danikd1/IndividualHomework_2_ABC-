.data 
pi: .double 3.14159265359
answer_pi: .asciz "π: "
accuracy: .double 0.001


.globl answer_pi
.include "function.s" 
.include "output.s"
.text

	fld fs1 accuracy t0 	#constans # Загрузить значение 'accuracy' в fs1
	li s2 6
	fcvt.d.w fs2 s2 	#Конвертировать 6 в double и сохранить в fs2
	li s3 2
	fcvt.d.w fs3 s3		#Конвертировать 2 в double и сохранить в fs3
	li s4 1
	fcvt.d.w fs4 s4		#Конвертировать 1 в double и сохранить в fs4
	
	fld fs5 pi t0 	#Загрузить значение 'pi' в f5
	
	# Точность необходимая для π равная 0.1% от его значения
	fmul.d  fa6 fs1 fs5  	#Умножение accuracy на pi и сохранение результата в f6
	
	# Нахоим значение для приближения зета-функции, взято из условия для π
	fmul.d fa7 fa6 fa6  	#Возводим в квадрат
	fdiv.d ft3 fa7 fs2 	#Деление квадрата на 6 и сохранение результата в ft3
	
	approximate_zeta(s3, ft3) 	#Аппроксимация дзета-функции Римана (s3 - сумма квадратов обратных чисел, ft3 - значение толерантности) 
main:
	calculate_pi(ft2)  #Значение дзета-функции для вычисления приближенного значения числа π (ft2 - накопленная сумма, которая является приближенным значением дзета-функции Римана )
output:
	output(ft0) 	#Вывод в консоль приближенного значения числа π (ft0 - приближенное значения числа π)
exit:
	li a7 10
	ecall
